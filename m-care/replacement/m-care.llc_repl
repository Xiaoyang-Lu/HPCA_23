#include "cache.h"
#include <cstdlib>
#include <ctime>

#define NUM_CORE NUM_CPUS
#define MAX_LLC_SETS LLC_SET
#define LLC_WAYS LLC_WAY

#define SAT_INC(x,max)  (x<max)?x+1:x
#define SAT_DEC(x)      (x>0)?x-1:x
#define TRUE 1
#define FALSE 0
#
#define RRIP_OVERRIDE_PERC   0

#define maxRRPV 3
uint32_t line_rrpv[MAX_LLC_SETS][LLC_WAYS];
uint32_t is_prefetch[MAX_LLC_SETS][LLC_WAYS];
uint32_t fill_core[MAX_LLC_SETS][LLC_WAYS];

#define NUM_LEADER_SETS   64

uint32_t ship_sample[MAX_LLC_SETS];
uint32_t line_reuse[MAX_LLC_SETS][LLC_WAYS];
uint64_t line_sig[MAX_LLC_SETS][LLC_WAYS];

#define maxSHCTR 7
#define SHCT_SIZE (1<<14)



class SHCT_class {
  public:
    uint32_t counter;
    uint32_t pmcl;

    SHCT_class() {
        counter = 1;
        pmcl = (1 + maxSHCTR)/2;
    };
};


SHCT_class SHCT[NUM_CORE][SHCT_SIZE];




uint64_t insertion_distrib[NUM_TYPES][maxRRPV+1];
uint64_t total_prefetch_downgrades;


// initialize replacement state
void CACHE::llc_initialize_replacement()
{
    int LLC_SETS =  MAX_LLC_SETS;

    for (int i=0; i<MAX_LLC_SETS; i++) {
        for (int j=0; j<LLC_WAYS; j++) {
            line_rrpv[i][j] = maxRRPV;
            line_reuse[i][j] = FALSE;
            is_prefetch[i][j] = FALSE;
            line_sig[i][j] = 0;
        }
    }

    for (int i=0; i<NUM_CORE; i++) {
        for (int j=0; j<SHCT_SIZE; j++) {
            SHCT[i][j].counter = 1; // Assume weakly re-use start
	    SHCT[i][j].pmcl = (1 + maxSHCTR)/2;
        }
    }

    int leaders=0;

    while(leaders<NUM_LEADER_SETS){
      int randval = rand()%LLC_SETS;
      
      if(ship_sample[randval]==0){
	ship_sample[randval]=1;
	leaders++;
      }
    }
}


// find replacement victim
uint32_t CACHE::llc_find_victim(uint32_t cpu, uint64_t instr_id, uint32_t set, const BLOCK *current_set, uint64_t ip, uint64_t full_addr, uint32_t type)
{
    while (1)
    {
        for (int i=0; i<LLC_WAYS; i++)
            if (line_rrpv[set][i] == maxRRPV) { // found victim
                return i;
            }

        for (int i=0; i<LLC_WAYS; i++)
            line_rrpv[set][i]++;
    }
    assert(0);
    return 0;
}

// called on every cache hit and cache fill
void CACHE::llc_update_replacement_state(uint32_t cpu, uint32_t set, uint32_t way, uint64_t full_addr, uint64_t ip, uint64_t victim_addr, uint32_t type, uint8_t hit)
{

  uint32_t sig   = line_sig[set][way];
    
  int pmc_level = 0;

    if(!hit)
    {
        if(type == WRITEBACK)
        {
                pmc_level = 0;
        }
        else if(0 <= block[set][way].pmc && block[set][way].pmc <= 119)
        {
                pmc_level = 0;
        }
        else if (120 <= block[set][way].pmc && block[set][way].pmc <= 239)
        {
                pmc_level = 1;
        }
        else if (240 <= block[set][way].pmc && block[set][way].pmc <= 359)
        {
                pmc_level = 2;
        }
        else
        {
                pmc_level = 3;
        }
    }


    if (hit) { // update to REREF on hit
        if( type != WRITEBACK ) 
        {

            if( (type == PREFETCH) && is_prefetch[set][way] )
            {
//                line_rrpv[set][way] = 0;
                
                if( (ship_sample[set] == 1) && ((rand()%100 <5) )) 
                {
                    uint32_t fill_cpu = fill_core[set][way];

                    SHCT[fill_cpu][sig].counter = SAT_INC(SHCT[fill_cpu][sig].counter, maxSHCTR);
                    line_reuse[set][way] = TRUE;
                }
            }
            else 
            {
		uint32_t fill_cpu = fill_core[set][way];
		if(SHCT[fill_cpu][sig].counter != 0)
		{
			line_rrpv[set][way] = 0;
		}
		else
		{
			if (line_rrpv[set][way] > 0)
			{
				line_rrpv[set][way]--;
			}
		}

                if( is_prefetch[set][way] )
                {
                    line_rrpv[set][way] = maxRRPV;
                    is_prefetch[set][way] = FALSE;
                    total_prefetch_downgrades++;
                }

                if( (ship_sample[set] == 1) && (line_reuse[set][way]==0) ) 
                {
                    uint32_t fill_cpu = fill_core[set][way];

                    SHCT[fill_cpu][sig].counter = SAT_INC(SHCT[fill_cpu][sig].counter, maxSHCTR);
                    line_reuse[set][way] = TRUE;
                }
            }
        }
        
	return;
    }
    
    //--- All of the below is done only on misses -------
    // remember signature of what is being inserted
    uint64_t use_PC = (type == PREFETCH ) ? ((ip << 1) + 1) : (ip<<1);
    uint32_t new_sig = use_PC%SHCT_SIZE;
    
    if( ship_sample[set] == 1 ) 
    {
        uint32_t fill_cpu = fill_core[set][way];
        
        // update signature based on what is getting evicted
        if (line_reuse[set][way] == FALSE) { 
            SHCT[fill_cpu][sig].counter = SAT_DEC(SHCT[fill_cpu][sig].counter);
        }
        else 
        {
            	SHCT[fill_cpu][sig].counter = SAT_INC(SHCT[fill_cpu][sig].counter, maxSHCTR);
        }
	if(pmc_level == 0)
	{
		SHCT[fill_cpu][sig].pmcl = SAT_DEC(SHCT[fill_cpu][sig].pmcl);
	}	
	else if (pmc_level == 3)
	{
		SHCT[fill_cpu][sig].pmcl = SAT_INC(SHCT[fill_cpu][sig].pmcl, maxSHCTR);
	}


        line_reuse[set][way] = FALSE;
        line_sig[set][way]   = new_sig;  
        fill_core[set][way]  = cpu;
    }



    is_prefetch[set][way] = (type == PREFETCH);

    // Now determine the insertion prediciton

    uint32_t priority_RRPV = maxRRPV-1 ; // default SHIP

    if( type == WRITEBACK )
    {
        line_rrpv[set][way] = maxRRPV;
    }
    else if (SHCT[cpu][new_sig].counter == 0) {
      line_rrpv[set][way] = (rand()%100>=RRIP_OVERRIDE_PERC)?  maxRRPV: priority_RRPV; //LowPriorityInstallMostly
    }
    else if (SHCT[cpu][new_sig].counter == 7) {
        line_rrpv[set][way] = (type == PREFETCH) ? 1 : 0; // HighPriority Install
    }
    else 
    {
	if(SHCT[cpu][new_sig].pmcl == 0)
	{
		line_rrpv[set][way] = 6;
	}
	else if (SHCT[cpu][new_sig].pmcl == 7)
	{
		line_rrpv[set][way] = 2;
	}
	else
	{
		line_rrpv[set][way] = 4;
	}
    }

    // Stat tracking for what insertion it was at
    insertion_distrib[type][line_rrpv[set][way]]++;


}

// use this function to print out your own stats at the end of simulation
void CACHE::llc_replacement_final_stats()
{

}
